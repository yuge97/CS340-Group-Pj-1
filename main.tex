\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}
\usepackage[]{algorithm2e}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm,enumerate}
\usepackage{amsmath}
\usepackage{parskip}

\graphicspath{ {images/} }

\newtheorem*{theorem}{Theorem}
\newtheorem*{lemma}{Lemma}
%SetFonts

\title{CS340 - Group Project}
\author{Caroline Shen, Rose Lin, Sunny Qi}
\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle
\section{Abstract}
We designed a greedy algorithm to solve the scheduling problem. To be brief, every time we assign a slot for a specific class, we try to minimize the its conflict. The restriction taken into consideration are professor conflicts, room restriction and student conflict.
%We based our algorithm on greedy algorithm, which means that every time when we have to set a time slot and a room for a certain class, we pick the optimal classroom and time slot so that the same professor do not need to teach two or three classes at the same time, and by the mean time, the number of students who want to take this class are able to take that class is the more the better.

From the implementation of our algorithm and that of our test method, we find out that the satisfaction rate lies between 75\% and 100\% on basic data, and 77.6\% on data from Haverford. 

%By running code on our algorithm to test how our algorithm works on the basic data and Haverford data, we find out that only about 70\% percent of student preferences can be satisfied on the basic data. However, after running algorithm on Haverford data we find out that about 90\% of students preference can be satisfied. 

%\newpage
\section{Algorithm}
\subsection{Description}
We schedule all classes base on their popularity. The popularity of a specific class is defined as the the number of students who put the class on their preference lists.

%Then we sort all rooms by their sizes from small to large. 
Starting from the most popular class, we try to assign the class to the largest classroom $c$ it can fit in. For each time slots $t$ available under $c$, we check this course with all courses in the same time slot. 
%If it is not taught by the same professor as any course in the same time, assign the class to this time. 
If there is no professor conflict in this time slot of all rooms, then we assign the class to time slot $t$ and room $c$.
If there is no such empty time slot in this room, move to the next largest room and repeatedly checking for such a time slot. 

If such a time slot doesn't exist in all rooms that can fit that class, we move to rooms that have capacity less than the number of people registered and find a time slot without conflict and squeeze the class into that room. There has to be such a room since the product of the number of time slot and the number of rooms must be greater than the number of total classes by the way we setup the data. If there are more classes than the product, we just don't assign the rest of the classes.

\subsection{Pseudocode for Haverford case}
\begin{algorithm}
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Scheduling}{}{}
\Fn{\Scheduling{(Classes, Students, Professors, Times, Rooms)}}{
    Initially, Rooms is a list of rooms sorted by their capacity in increasing order.
    
    Initially, Students is a list of students
    
    Initially, Professors is a list of professors indexed with class\_id
    
    Initially, Times is a list of time slots.
    
    $T_1$[] = a list of time slots that do not overlap with each other
    
    $T_2[]$ = a list of all remaining time slots
    
    schedule S[][] all initialized to 0. 
    
    len(S) = len($T_1$) and len(S[0]) = len(Rooms)
    
    schedule S'[][] all initialized to 0.
    
    len(S') = len($T_2$) and len(s'[0]) = len(Rooms)
    
    Position P[] 
    
    Position P'[]
    
    Calculate popularity of each class, and sort all classes by popularity in decreasing order.
    
    S[][] = fillSchedule(S, P, Classes, $T_1$, Rooms, Professors)
    
    
    \While{there are still classes not scheduled}{
        S'[][] = fillSchedule(S',P', Classes, $T_2$, Rooms, Professors)
    }
    return S[][], S'[][], P[], P'[]
}
\end{algorithm}

\begin{algorithm}
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{fillSchedule}{}{}
\Fn{\test{(S, P, Classes, Times, Rooms, Professors )}}{
    \For{each class c $\in$ Classes}{
        pop = the popularity of c
        
        \While{there is a room with capacity larger than pop that has not been checked or c is not assigned a time slot}{
        
            Find out the smallest room $r$, whose capacity is greater than pop.
        
            \For{each time t in Times}{
                
                Check all $Schedule[t][i] (0 < i < r)$
            
                Find empty time slot t' without professor conflict
                
                \If{t' exists}{
                    Assign the time slot t' to $c$, S[t'][r] = c
                    
                    $P[c] = (t',r)$
                    
                    break
                }
               
            }
            \If{t' does not exist}{
                pop = the capacity of $r$
           }
        }
        
    }
    return S
}
\end{algorithm}

\begin{algorithm}
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Test}{}{}
\Fn{\test{(S, Pref, Schedule, Position)}}{
    $count = 0$
    
    $total = 0$

    \For{each student s in S}{
        $total +=$ len$(Pref[s])$
    
        final pick = [0]$\times$ len$(Schedule)$

        \For{each class c in Pref[s]}{
            \If{c in Position}{
                $t = Position[c][0]$    
            
                \If{final pick[t] is empty}{
                    final pick[$t$] = $c$
                 
                    $count += 1$
                }
            }
            \Else{
                $total -= 1$
            }
        }
    }
    return $count/total$
}
\end{algorithm}

\subsection{Pseudocode for basic data}
\begin{algorithm}[H]
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Scheduling}{}{}
\Fn{\Scheduling{(Classes, Students, Professors, Times, Rooms)}}{
    Initially, Rooms is a list of rooms sorted by their capacity in increasing order.
    
    Initially, Students is a list of students
    
    Initially, Professors is a list of professors indexed with class\_id
    
    Initially, Times is a list of time slots.
    
    $T$[] = a list of time slots
    
    schedule S[][] all initialized to 0. 
    
    len(S) = len($T$) $\times$ len(Rooms)
    
    Position P[] 
    
    room\_dict = {}
    
    Calculate popularity of each class, and sort all classes by popularity in decreasing order.
    
    \For{each class c $\in$ Classes}{
        pop = the popularity of c
        
        \While{there is a room with capacity larger than pop that has not been checked or c is not assigned a time slot}{
        
            Find out the smallest room $r$, whose capacity is greater than pop.
        
            \For{each time t in Times}{
                
                Check all $S[t][i] (0 < i < r)$
            
                Find empty time slot t' without professor conflict
                
                \If{t' exists}{
                    Assign the time slot t' to $c$, S[t'][r] = c
                    
                    $P[c] = (t',r)$
                    
                    break
                }
               
            }
            \If{t' does not exist}{
                pop = the capacity of $r$
           }
           
           $room\_dict[c] = (t + 1, room\_id)$
        }
        
    }
    
    return S[][], P[], room\_dict
}
\end{algorithm}

\begin{algorithm}[H]
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Test}{}{}
\Fn{\test{(S, Pref, Schedule, Position)}}{
    $count = 0$
    
    $total = 0$

    \For{each student s in S}{
        $total +=$ len$(Pref[s])$
    
        final pick = [0]$\times$ len$(Schedule)$

        \For{each class c in Pref[s]}{
            \If{c in Position}{
                $t = Position[c][0]$    
            
                \If{final pick[t] is empty}{
                    final pick[$t$] = $c$
                 
                    $count += 1$
                }
            }
            \Else{
                $total -= 1$
            }
        }
    }
    return $count/total$
}
\end{algorithm}


\subsection{Time Analysis}
Let \textbf{n} be the number of students. 

Let \textbf{l} be the average length of each student's preference list.

Let \textbf{m} be the total number of classes. 

Let \textbf{r} be the number of rooms. 

Let \textbf{t} be the number of time slots. 

Notice that $r$ and $t$ are strictly smaller than $n$.

Calculating the popularity of each class takes $O(n \times l)$. Sorting all classes takes $O(m\log m)$. The first for loop in Scheduling() runs \textbf{m} iterations. Finding out the smallest room each class can fit takes $O(r)$. The inner for loop runs \textbf{t} iterations. Checking professor conflicts for each class runs $t \times r$ times. The while loop runs \textbf{r} times in the worse case. So the whole loops will run $O(m) \cdot O(r) \cdot (O(r) + O(tr)) = O(mtr^2)$. Since in this case $t$ is only a small constant, we can simplify the run time to be $O(mr^2)$. 

Thus the algorithm runs in $O(nl) + O(m\log m) + O(mr^2) = O(nl) + O(mr^2)$, depends on the value of $nl$ and $mr^2$.

\subsubsection{Data Structure}
For the basic case, we need to build a 2D array $Schedule$ in the function scheduling, and an array $T$ to be the list of time slots and we also need to build an array $P$ to denote the position of the courses. We also need a dictionary $room\_dict$, which is keyed with class id and use (time\_slot, room\_id) in the $Schedule$ as its value. 

For the Haverford data, we also need to build two 2D arrays $Schedule$ and $overlapping\_schedule$ in the function scheduling, and four dictionaries, $room\_index\_dict$, which is keyed by the room index, $Position$, which is keyed by class id, $room\_dict$, which is also keyed by class id and use (time\_slot, room\_id) in the $Schedule$ as its value, and $over\_position$, which is keyed by class id.

\subsection{Proof of Correctness}
To prove that this algorithm works, two parts need to be shown.

1. Proof of termination.

2. Proof of validity.

\textit{Proof of termination:}

For the basic case, build all variables only takes $O(1)$. Since the number of classes, students, professors, time slots, and rooms are all finite, calculating the popularity of each classes must terminate, and sorting all classes by popularity will terminate in the same reason. Then the first for loop will terminate because the number of classes is finite, the inner while loop will also terminate since the numbers of rooms and time slot are finite, the second for loop will also terminate since the number of elements in Times is also finite. All operations in the inner most for loop will also terminate since the number of classes, students, professors, time slots, and rooms are all finite. Since all loops in this algorithm will terminate, the algorithm will then terminate. \\

For the Haverford case, all process are the same until it reaches where we call another function fillSchedule(). In the function fillSchedule(), the first for loop will terminate because the number of classes is finite, the inner while loop will also terminate since the numbers of rooms and time slot are finite, the second for loop will also terminate since the number of elements in Times is also finite. All operations in the inner most for loop will also terminate since the number of classes, students, professors, time slots, and rooms are all finite. Then the function will terminate. The following while loop will terminate since there must be a way to schedule all classes. Thus all loops in this algorithm terminate, which means that the algorithm will terminate. \\

\textit{Proof of validity:}

For the basic data, we'll prove by contradiction. Suppose that our algorithm cannot give a valid result, which means that there must be some classes not been put into the class schedule. However, since when we multiplying the number of rooms and time slots, we find out that the number of the multiplication is much bigger than the number of classes or number of professors, it is impossible for some class not being able to be put into the class schedule, which is a contradiction.

For the Haverfod data,

Thus our algorithm will give a valid scheduling of all classes.

\subsection{Discussion}
We decided to choose the greedy algorithm because by the first check point time for this project, the only algorithm we learned was greedy algorithm, and as the purpose for this project was finding the most optimal way of scheduling all classes, we thought that greedy algorithm was actually one of the best choices for this problem. Then we came up with the problem that what conditions should we base our algorithm on.

We first decided to schedule different classes according to how many students want to take both classes, and schedule the two classes with the highest overlapping ratio in different time slots. So we prioritizing popular classes that students want to take at the same time, and set the first valid room that can fit students and then put it in a time slot. If we can't find such a valid room, we will then put the certain class into the first classroom with capacity smaller than the class size. In this way there must be some students cannot take the class they want to take, but we maximize the classes that each students want to take.

In the mean time, we are taking the classroom and professor's availability into consideration. We try to avoid the situation where 2 classes in the same time slot are taught by the same professor. Also, the class size won't exceed the capacity of the classrooms. If there are an unavoidable conflict, we will sacrifice the smallest number of students that are involved in this conflict.

We then found out that only about 70\% students could take the classes that they wanted to take. Then for the real Haverford data, the popularity of a certain class is actually determined not only by its topic, but also by its class level or difficulty, and since it is a real data, we should actually make all students to take the classes they wanted to take. 

We found out that our algorithm can only let 70\% students take the classes that they took, and we need to change our algorithm a little bit. Also, we did not distinguish class times between only need to take that class in a particular day in a week and need to take the same class twice or three times in a week. 

Then the first thing we did is to combine classes that students should take twice or three times a week. We added the keys in the dictionary, and wrote new function to deal with time slots that have overlaps (e.g classes on Monday and Wednesday morning 10:30 to 11:30 and classes on Monday and Wednesday morning 10:00 to 11:30 have overlaps). Then we basically assign students for classes that have no overlapping, and then assign students for classes that have overlaps. 

We then decided to add the building that different classes should be held in into consideration. For example, STEM classes will only be held in KINSK Building in Haverford and in Park Building in Bryn Mawr. So we wrote new functions to get the information of which classes are held in which building, and which majors have what classes.
%% Need to change

\subsection{Extra Constraints}
For Haverford data, we are adding in several more constraints to make the schedule more realistic.
\subsubsection{Departments and Buildings}
We also concerned about the building that different courses are put in. For example, STEM classes will only be held in KINSK Building in Haverford. 

In order to take in concern of this constraint, we parse extra data from the csv file: the subject a class belongs to and also all the rooms in which a certain subject could be held. Store them into two dictionaries: one is with the class number as key and their subject as value, the other where the subject is the key and the list of rooms they are allowed to be held in as value. Therefore, when we schedule a certain class, we find the department it belongs to and only schedule classes in rooms that belongs to that department.

However, getting all information from the csv file can be problematic. For example, a single class number might represent different classes, and consequently, different departments. Such as class 9 represent classes with 3 different subjects. In this case, we only assign it the subject where it first appears. Another problem with this is that we are getting the rooms of certain subject from the csv file. This file, however, might only contain a portion of all possible rooms in that building. This fall will definitely reduce our performance score. But we choose to keep it this way because come up with all possible rooms by imagination could be an arduous work and would sacrifice a great amount of run time.
\subsubsection{Overlapping time slots}
We also consider the overlapping time slots that are given in the Haverford data.

Low level classes and higher level classes in the same department can be put in the same time slot. 

Moreover, most low level intro classes will be held three times a week, while most upper level classes will only be held twice or even once a week. When we are distributing the classes, we can also put that into consideration. Also, for foreign language classes which are held five times a week, we should try our best to put that into the schedule that has the least conflicts with other lower level classes. 

\subsection{Improvements}
We didn't concern the courses that Haverford students took in Bryn Mawr, which means that we basically just concern about the classes that are held in Haverford. Also, we didn't take the labs for different classes into consideration.


\section{Experimental Analysis}
%\subsection{Time Analysis}
%Based on our time analysis, the run time is roughly linear to $mr^2 + nl$.

%\subsection{Solution Quality Analysis}
For Haverford data, we can satisfy around 77\% student preference. This number is fixed; so in order to actually test our algorithm, we run the basic data and compare the difference of satisfaction rate and time needed.

By generating different sets of basic data and apply our algorithm, we get the following table for the basic data (next page):
\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|l|}
\hline
\# of rooms & \# of classes & \# of class times & \# of students & percentage & time     \\ \hline
10          & 30            & 10                & 200            & 0.88125    & 0.00295  \\ \hline
10          & 80            & 10                & 200            & 0.86125    & 0.00407  \\ \hline
5           & 80            & 20                & 200            & 0.94875    & 0.00285  \\ \hline
20          & 80            & 5                 & 200            & 0.73625    & 0.003806 \\ \hline
50          & 200           & 50                & 1000           & 0.97525    & 0.03513  \\ \hline
500         & 200           & 50                & 1000           & 0.9575     & 2.2292   \\ \hline
500         & 200           & 50                & 1000           & 0.89945    & 2.12678  \\ \hline
100         & 4500          & 50                & 10000          & 0.972125   & 1.20007  \\ \hline
100         & 4500          & 100               & 10000          & 0.985625   & 1.32053  \\ \hline
\end{tabular}
\end{table}
\subsection{Optimization Analysis}
Notice that the first 4 lines focus on the satisfaction rate analysis and the last 5 lines focus on the run time of the algorithm on different data sets.

For the first 4 lines, the total empty slots, namely the product of number of rooms and the number of class times is always 100 and the number of student is fixed at 200. Changing other factors of the data can show the factors that influence the satisfaction rate. If we have same number of rooms and time slots, the increasing number of classes would decrease the satisfaction rate. If we fix the number of classes to be 80 and increase the rate of rooms/times, we are getting a decreased percent satisfaction. This is because less number of time slots will result in higher possibility of conflicts intuitively. On the contrary, if we increase the number of time slots, the probability of course conflict will reduce accordingly.
\subsection{Run Time Analysis}


% we are satisfying around \%80 student preference. However, we are not considering time slot overlapping. In other words, for two time slots one from 1 to 4 pm on Monday, and the other one from 1 to 2 pm on Monday, we are considering them as non overlapping slots. Thus the actual quality of Haverford data should be worse 80\%. Based on out time analysis, the runtime is roughly linear to $mtr$. For $mrt$ as small as a few hundreds, the program runs within 0.001 seconds. For $mrt$ around 30000, the program runs around 0.01 seconds. For $mrt$ as large as 2 millions, the program runs around 0.4 second. Roughly speaking, the runtime of the algorithm is proportional to $mtr$. 

% However, the actual satisfaction should be less, since we are not considering time slot overlapping. In other words, for two time slots one from 1 to 4 pm on Monday, and the other one from 1 to 2 pm on Monday, we are considering them as non overlapping slots. Thus the actual quality of haverford data should be worse than 80\%.



\newpage
\section{Recommendations}
There should be no restrictions on where the classes should be held, for example, STEM classes should also be held outside the KINSK building. 

\end{document}
