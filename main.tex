\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}
\usepackage[]{algorithm2e}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm,enumerate}
\usepackage{amsmath}
\usepackage{parskip}

\graphicspath{ {images/} }

\newtheorem*{theorem}{Theorem}
\newtheorem*{lemma}{Lemma}
%SetFonts

\title{CS340 - Group Project}
\author{Caroline Shen, Rose Lin, Sunny Qi}
\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle
\section{Abstract}
We designed a greedy algorithm to solve the scheduling problem. To be brief, every time we assign a slot for a specific class, we try to minimize the its conflict. The restriction taken into consideration are professor conflicts, room restriction and student conflict.
%We based our algorithm on greedy algorithm, which means that every time when we have to set a time slot and a room for a certain class, we pick the optimal classroom and time slot so that the same professor do not need to teach two or three classes at the same time, and by the mean time, the number of students who want to take this class are able to take that class is the more the better.

From the implementation of our algorithm and that of our test method, we find out that the satisfaction rate lies between 70\% and 75\% on basic data, and 87.9\% on data from Haverford. 

%By running code on our algorithm to test how our algorithm works on the basic data and Haverford data, we find out that only about 70\% percent of student preferences can be satisfied on the basic data. However, after running algorithm on Haverford data we find out that about 90\% of students preference can be satisfied. 

%\newpage
\section{Algorithm}
\subsection{Description}
We schedule all classes base on their popularity. The popularity of a specific class is defined as the the number of students who put the class on their preference lists.

%Then we sort all rooms by their sizes from small to large. 
Starting from the most popular class, we try to assign the class to the smallest classroom $c$ it can fit in. For each time slots $t$ available under $c$, we check this course with all courses in the same time slot. 
%If it is not taught by the same professor as any course in the same time, assign the class to this time. 
If there is no professor conflict in this time slot of all rooms, then we assign the class to time slot $t$ and room $c$.
If there is no such empty time slot in this room, move to the next largest room and repeatedly checking for such a time slot. 

If such a time slot doesn't exist in all rooms that can fit that class, we move to rooms that have capacity less than the number of people registered and find a time slot without conflict and squeeze the class into that room. There has to be such a room since the product of the number of time slot and the number of rooms must be greater than the number of total classes by the way we setup the data. If there are more classes than the product, we just don't assign the rest of the classes.

\subsection{Pseudocode for Haverford case}
\begin{algorithm}
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Scheduling}{}{}
\Fn{\Scheduling{(Classes, Students, Professors, Times, Rooms)}}{
    Initially, Rooms is a list of rooms sorted by their capacity in increasing order.
    
    Initially, Students is a list of students
    
    Initially, Professors is a list of professors indexed with class\_id
    
    Initially, Times is a list of time slots.
    
    $T_1$[] = a list of time slots that do not overlap with each other
    
    $T_2[]$ = a list of all remaining time slots
    
    schedule S[][] all initialized to 0. 
    
    len(S) = len($T_1$) and len(S[0]) = len(Rooms)
    
    schedule S'[][] all initialized to 0.
    
    len(S') = len($T_2$) and len(s'[0]) = len(Rooms)
    
    Position P[] 
    
    Position P'[]
    
    Calculate popularity of each class, and sort all classes by popularity in decreasing order.
    
    S[][] = fillSchedule(S, P, Classes, $T_1$, Rooms, Professors)
    
    
    \While{there are still classes not scheduled}{
        S'[][] = fillSchedule(S',P', Classes, $T_2$, Rooms, Professors)
    }
    return S[][], S'[][], P[], P'[]
}
\end{algorithm}

\begin{algorithm}
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{fillSchedule}{}{}
\Fn{\test{(S, P, Classes, Times, Rooms, Professors )}}{
    \For{each class c $\in$ Classes}{
        pop = the popularity of c
        
        \While{there is a room with capacity larger than pop that has not been checked or c is not assigned a time slot}{
        
            Find out the smallest room $r$, whose capacity is greater than pop.
        
            \For{each time t in Times}{
                
                Check all $Schedule[t][i] (0 < i < r)$
            
                Find empty time slot t' without professor conflict
                
                \If{t' exists}{
                    Assign the time slot t' to $c$, S[t'][r] = c
                    
                    $P[c] = (t',r)$
                    
                    break
                }
               
            }
            \If{t' does not exist}{
                pop = the capacity of $r$
           }
        }
        
    }
    return S
}
\end{algorithm}

\begin{algorithm}
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Test}{}{}
\Fn{\test{(S, Pref, Schedule, Position)}}{
    $count = 0$
    
    $total = 0$

    \For{each student s in S}{
        $total +=$ len$(Pref[s])$
    
        final pick = [0]$\times$ len$(Schedule)$

        \For{each class c in Pref[s]}{
            \If{c in Position}{
                $t = Position[c][0]$    
            
                \If{final pick[t] is empty}{
                    final pick[$t$] = $c$
                 
                    $count += 1$
                }
            }
            \Else{
                $total -= 1$
            }
        }
    }
    return $count/total$
}
\end{algorithm}

\subsection{Pseudocode for basic data}
\begin{algorithm}[H]
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Scheduling}{}{}
\Fn{\Scheduling{(Classes, Students, Professors, Times, Rooms)}}{
    Initially, Rooms is a list of rooms sorted by their capacity in increasing order.
    
    Initially, Students is a list of students
    
    Initially, Professors is a list of professors indexed with class\_id
    
    Initially, Times is a list of time slots.
    
    $T$[] = a list of time slots
    
    schedule S[][] all initialized to 0. 
    
    len(S) = len($T$) $\times$ len(Rooms)
    
    Position P[] 
    
    Calculate popularity of each class, and sort all classes by popularity in decreasing order.
    
    \For{each class c $\in$ Classes}{
        pop = the popularity of c
        
        \While{there is a room with capacity larger than pop that has not been checked or c is not assigned a time slot}{
        
            Find out the smallest room $r$, whose capacity is greater than pop.
        
            \For{each time t in Times}{
                
                Check all $S[t][i] (0 < i < r)$
            
                Find empty time slot t' without professor conflict
                
                \If{t' exists}{
                    Assign the time slot t' to $c$, S[t'][r] = c
                    
                    $P[c] = (t',r)$
                    
                    break
                }
               
            }
            \If{t' does not exist}{
                pop = the capacity of $r$
           }
        }
        
    }
    
    return S[][], P[], room\_dict
}
\end{algorithm}

\begin{algorithm}[H]
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Test}{}{}
\Fn{\test{(S, Pref, Schedule, Position)}}{
    $count = 0$
    
    $total = 0$

    \For{each student s in S}{
        $total +=$ len$(Pref[s])$
    
        final pick = [0]$\times$ len$(Schedule)$

        \For{each class c in Pref[s]}{
            \If{c in Position}{
                $t = Position[c][0]$    
            
                \If{final pick[t] is empty}{
                    final pick[$t$] = $c$
                 
                    $count += 1$
                }
            }
            \Else{
                $total -= 1$
            }
        }
    }
    return $count/total$
}
\end{algorithm}


\subsection{Time Analysis}
Let \textbf{n} be the number of students. 

Let \textbf{l} be the average length of each student's preference list.

Let \textbf{m} be the total number of classes. 

Let \textbf{r} be the number of rooms. 

Let \textbf{t} be the number of time slots. 

Notice that $r$ and $t$ are strictly smaller than $n$.

Calculating the popularity of each class takes $O(n \times l)$. Sorting all classes takes $O(m\log m)$. The first for loop in Scheduling() runs \textbf{m} iterations. Finding out the smallest room each class can fit takes $O(r)$. The inner for loop runs \textbf{t} iterations. Checking professor conflicts for each class runs $t \times r$ times. The while loop runs \textbf{r} times in the worse case. So the algorithm runs in $O(mtr^2)$.

\subsubsection{Data Structure}
We need to build a 2D array $Schedule$ in the function scheduling, and we also need to build two dictionaries, one is $Position$, which is keyed with class id, another one is $room\_dict$, which is keyed with class id and use (time\_slot, room\_id) in the $Schedule$ as its value. 


\subsection{Proof of Correctness}
To prove that this algorithm works, two parts need to be shown.

1. Proof of termination.

2. Proof of validity.

\textit{Proof of termination:}

Build all variables only takes $O(1)$. Since the number of classes, students, professors, time slots, and rooms are all finite, calculating the popularity of each classes must terminate, and sorting all classes by popularity will terminate in the same reason. Then the outer for loop will terminate because the number of classes is finite. Find the smallest room and an empty time slot will also not run infinitely many times. The inner for loop will also terminate as times is not infinite. Then in the inner for loop, check all elements in $Schedule$ will terminate, so did find the empty schedule. Since both for loops and their inner part will terminate, the algorithm will then terminate. \\

\textit{Proof of validity:}

We'll prove by contradiction. Suppose that our algorithm cannot give a valid result, which means that there must be some classes not been put into the class schedule. However, since when we multiplying the number of rooms and time slots, we find out that the number of the multiplication is much bigger than the number of classes or number of professors, it is impossible for some class not being able to be put into the class schedule, which is a contradiction.

Thus our algorithm will give a valid scheduling of all classes.

\subsection{Discussion}
We decided to choose the greedy algorithm because by the first check point time for this project, the only algorithm we learned was greedy algorithm, and as the purpose for this project was finding the most optimal way of scheduling all classes, we thought that greedy algorithm was actually one of the best choices for this problem. Then we came up with the problem that what conditions should we base our algorithm on.

We first decided to schedule different classes according to how many students want to take both classes, and schedule the two classes with the highest overlapping ratio in different time slots. So we prioritizing popular classes that students want to take at the same time, and set the first valid room that can fit students and then put it in a time slot. If we can't find such a valid room, we will then put the certain class into the first classroom with capacity smaller than the class size. In this way there must be some students cannot take the class they want to take, but we maximize the classes that each students want to take.

In the mean time, we are taking the classroom and professor's availability into consideration. We try to avoid the situation where 2 classes in the same time slot are taught by the same professor. Also, the class size won't exceed the capacity of the classrooms. If there are an unavoidable conflict, we will sacrifice the smallest number of students that are involved in this conflict.

We then found out that only about 70\% students could take the classes that they wanted to take. Then for the real Haverford data, the popularity of a certain class is actually determined not only by its topic, but also by its class level or difficulty, and since it is a real data, we should actually make all students to take the classes they wanted to take. 

We found out that our algorithm can only let 70\% students take the classes that they took, and we need to change our algorithm a little bit. Also, we did not distinguish class times between only need to take that class in a particular day in a week and need to take the same class twice or three times in a week. 

Then the first thing we did is to combine classes that students should take twice or three times a week. We added the keys in the dictionary, and wrote new function to deal with time slots that have overlaps (e.g classes on Monday and Wednesday morning 10:30 to 11:30 and classes on Monday and Wednesday morning 10:00 to 11:30 have overlaps). Then we basically assign students for classes that have no overlapping, and then assign students for classes that have overlaps. 

We then decided to add the building that different classes should be held in into consideration. For example, STEM classes will only be held in KINSK Building in Haverford and in Park Building in Bryn Mawr. So we wrote new functions to get the information of which classes are held in which building, and which majors have what classes.
%% Need to change

\subsection{Extra Constraints}
We also concerned about the building that different courses are put in. For example, STEM classes will only be held in KINSK Building in Haverford. 


%Moreover, most low level intro classes will be held three times a week, while most upper level classes will only be held twice or even once a week. When we are distributing the classes, we can also put that into consideration. Also, for foreign language classes which are held five times a week, we should try our best to put that into the schedule that has the least conflicts with other lower level classes. 

\subsection{Improvements}
We didn't concern the courses that Haverford students took in Bryn Mawr, which means that we basically just concern about the classes that are held in Haverford. Also, we didn't take the labs for different classes into consideration.



\newpage
\section{Experimental Analysis}
\subsection{Time Analysis}
Based on our time analysis, the run time is roughly linear to $mtr^2$.

\subsection{Solution Quality Analysis}
For basic data, we can satisfy around 75\% to 100\% student preference. For Haverford data, we can satisfy around 90\% student preference. % NEED TO CHECK

Table for the basic data:
\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|l|}
\hline
\# of rooms & \# of classes & \# of class times & \# of students & percentage & time     \\ \hline
10          & 30            & 10                & 200            & 0.88125    & 0.00295  \\ \hline
10          & 80            & 10                & 200            & 0.86125    & 0.00407  \\ \hline
5           & 80            & 20                & 200            & 0.94875    & 0.00285  \\ \hline
20          & 80            & 5                 & 200            & 0.73625    & 0.003806 \\ \hline
50          & 200           & 50                & 1000           & 0.97525    & 0.03513  \\ \hline
500         & 200           & 50                & 1000           & 0.972      & 2.2292   \\ \hline
50          & 200           & 500               & 1000           & 1          & 0.01889  \\ \hline
100         & 4500          & 50                & 10000          & 0.972125   & 1.20007  \\ \hline
100         & 4500          & 100               & 10000          & 0.985625   & 1.32053  \\ \hline
\end{tabular}
\end{table}

Table for the Haverford data:


% we are satisfying around \%80 student preference. However, we are not considering time slot overlapping. In other words, for two time slots one from 1 to 4 pm on Monday, and the other one from 1 to 2 pm on Monday, we are considering them as non overlapping slots. Thus the actual quality of Haverford data should be worse 80\%. Based on out time analysis, the runtime is roughly linear to $mtr$. For $mrt$ as small as a few hundreds, the program runs within 0.001 seconds. For $mrt$ around 30000, the program runs around 0.01 seconds. For $mrt$ as large as 2 millions, the program runs around 0.4 second. Roughly speaking, the runtime of the algorithm is proportional to $mtr$. 

% However, the actual satisfaction should be less, since we are not considering time slot overlapping. In other words, for two time slots one from 1 to 4 pm on Monday, and the other one from 1 to 2 pm on Monday, we are considering them as non overlapping slots. Thus the actual quality of haverford data should be worse than 80\%.



\newpage
\section{Recommendations}
% Change blue bus schedule?

\end{document}
