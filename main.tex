\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}
\usepackage[]{algorithm2e}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm,enumerate}
\usepackage{amsmath}
\usepackage{parskip}

\graphicspath{ {images/} }

\newtheorem*{theorem}{Theorem}
\newtheorem*{lemma}{Lemma}
%SetFonts

\title{CS340 - Group Project 1}
\author{Caroline Shen, Rose Lin, Sunny Qi}
\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle


\section{Algorithm Description}
We schedule all classes using the popularity of each class as main criteria. First we traverse over the student preference list and find out the number of student who want to attend each class and sort the classes from the most popular to the least popular. 

Then we sort all rooms by their sizes from small to large. Starting from the most popular class, try to assign the class to the smallest classroom $c$ it can fit in. For each time slots $t$ for $c$, check this course with all courses in the same time slot. If it is not taught by the same professor as any course in the same time, assign the class to this time. If there is no such empty time slot in this room, move to the next largest room and repeatedly checking for such a time slot. 

If such a time slot doesn't exist in all rooms that can fit that class. We move to rooms that have capacity less than the number of people registered and find a time slot without conflict and squeeze the class into that room. There has to be such a room since the product of the number of time slot and the number of rooms must be greater than the number of total classes by the way we setup the data. If there are more classes than the product, we just don't assign the rest of the classes.

\section{Pseudo-code}
\begin{algorithm}[H]
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{Scheduling}{(C, S, P, T, R)}{}
\Fn{\Scheduling{}}{
    Schedule[][]
    
    Position = []
    
    Calculate popularity of each class.
    
    Sort all classes by popularity. 
    
    \For{each class c $\in$ C}{
        Find out the smallest room it can fit with an empty time slot, r.
        
        \For{each time t in T}{
            %optional, need further discussion
            
            check all Schedule[t][$r-i$] ($0<i < r$)
        
            Find empty Schedule[t][r] without professor conflict= c
            
            Position[c] = (t,r)
        }
        
    }
    return schedule[][], Position
    
}
\end{algorithm}

\begin{algorithm}[H]
\SetKwFunction{foo}{foo}
\SetKwProg{Fn}{test}{(S, Pref, Schedule, Position)}{}
\Fn{\test{}}{
    count = 0

    \For{each student s in S}{
        final pick = [0]$\times len(Schedule)$

        \For{each class c in Pref[s]}{

            t = Position[c][0]      
            
            \If{final pick[t] is empty}{
                 final pick[t] = c
                 
                 count += 1 
            }
        }
    }
    return $count/(len(Pref[0])\times len(S))$
}

\end{algorithm}
\section{Time Analysis}
Let \textbf{n} be the number of students. 
Let \textbf{l} be the average length of each student's preference list.
Let \textbf{m} be the total number of classes. 
Let \textbf{r} be the number of rooms. 
Let \textbf{t} be the number of time slots. 
Notice that $p$ and $t$ are strictly smaller than $n$.

Calculating the popularity of each class takes $O(n\times l)$. Sorting all classes takes $O(mlogm)$. The first for loop in Scheduling() runs \textbf{m} iterations. Finding out the smallest room each class can fit takes $O(1)$. The inner for loop runs \textbf{t} iterations. Checking all schedules runs $t \times r$ times, totally. So the algorithm runs in $O(mtr)$.

\section{Experimental Analysis}
\subsection{Time Analysis}
Based on out time analysis, the runtime is roughly linear to $mtr$. For $mrt$ as small as a few hundreds, the program runs within 0.001 seconds. For $mrt$ around 30000, the program runs around 0.01 seconds. For $mrt$ as large as 2 millions, the program runs around 0.4 second. Roughly speaking, the runtime of the algorithm is proportional to $mtr$. 

\subsection{Solution Quality Analysis}
For basic data, we can satisfy around 70\% to 75\% student preference. For haverford data, we are satisfying around \%80 student preference. However, the actual satisfaction should be less, since we are not considering time slot overlapping. In other words, for two time slots one from 1 to 4 pm on Monday, and the other one from 1 to 2 pm on Monday, we are considering them as non overlapping slots. Thus the actual quality of haverford data should be worse than 80\%.

\section{Discussion}
\subsection{Possible improvements}
This time for the basic case we prioritizing popular classes that students want to take at the same time, and set the first valid room that can fit students and then put it in a time slot. If we can't find such a valid room, we will then put the certain class into the first classroom with capacity smaller than the class size. In this way there must be some students cannot take the class they want to take, but we maximize the classes that each students want to take.

In the mean time, we are taking the classroom and professor's availability into consideration. We try to avoid the situation where 2 classes in the same time slot are taught by the same professor. Also, the class size won't exceed the capacity of the classrooms. If there are an unavoidable conflict, we will sacrifice the smallest number of students that are involved in this conflict.

However, in this way, when we are computing the optimality, the optimality should be affected since we might brutally put some classes into a classroom that cannot hold the number of students that want to take that class. Yet when we were computing the optimality we didn't concern about that. Also, there might be rooms or time slots that can better fit the certain class than the way we use to set.

The optimality for the most basic where the number of class is nearly the same as the product of rooms and number of time slots is slightly greater than 70 percent. We will improve this number next time. Now we only put the class into a certain time slot if there is no professor conflicts with classes in the same time slot. Next time we could improve this by choosing the valid time slot with the least number of courses in it to avoid conflicts.

\subsection{Haverford data and possible constraints}
Our algorithm for scheduling classes in Haverford doesn't change much, but this time since when we were parsing the Haverford data we did not distinguish class times between only need to take that class in a particular day in a week and need to take the same class twice or three times in a week (eg. suppose there are two classes, the first one is held on Tuesday from 1 to 4 pm, and the second one is held on Tuesday and Thursday from 1 to 2 pm. In our code we parsed the first class time into Tuesday 1 -- 4 pm and the second class time into Tuesday 1 -- 2 pm and Thursday 1 -- 2 pm, with no connection between these two time slots.) Therefore, in our algorithm a student may be distributed a class that is held on Tuesday 1 -- 4 pm (once a week) and another class that is held on Thursday 1 -- 2 pm, but this class should be held twice a week on Tuesday and Thursday afternoon.

Also, in the code we wrote we didn't concern the courses that Haverford students took in Bryn Mawr, which means that we basically just concern about the classes that are held in Haverford. Also, we didn't take the labs for different classes into consideration.

We might also need to concern about the building that different courses are put in. For example, STEM classes will only be held in KINSK Building in Haverford. we may also need to consider this. Moreover, most low level intro classes will be held three times a week, while most upper level classes will only be held twice or even once a week. When we are distributing the classes, we can also put that into consideration. Also, for foreign language classes which are held five times a week, we should try our best to put that into the schedule that has the least conflicts with other lower level classes. 


\end{document}
